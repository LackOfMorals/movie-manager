# Chapter 3: Create New Data

Now that you can read data, let's add the ability to create new movies. In this chapter, you'll learn about GraphQL mutations and form handling.


> It is assumed that you have a local copy of this repository.  If you have not, then clone it now
> - ```git clone https://github.com/LackOfMorals/movie-manager.git```
> 
> And then move into this chapter
> - ```cd movie-manager/chapter3```



## Understanding GraphQL Mutations

While queries read data, **mutations** modify data. Mutations can:

- Create new nodes (entities)
- Update existing nodes
- Delete nodes
- Create or remove relationships

Here's a basic mutation:

```graphql
mutation CreateMovies {
    createMovies(input: { title: "AirPlane!", released: 1980 }) {
        movies {
            released
            title
        }
    }
}
```
 The mutation creates a new movie, Airplane!, with a release date of 1980 and returns the created data. 

> ***GraphQL*** will always require you to return one or more fields when performing a mutation.  The fields that can be returned are defined as part of the GraphQL schema


## Add Mutation Operations

 `src/graphql/operations.ts` contains the mutation that will be used to create movies and people.     


```typescript
export const CREATE_MOVIE = gql`
  mutation CreateMovie($title: String!, $released: Int!, $tagline: String) {
    createMovies(
      input: [{ 
        title: $title, 
        released: $released, 
        tagline: $tagline 
      }]
    ) {
      movies {
        title
        released
        tagline
      }
    }
  }
`;

export const CREATE_PERSON = gql`
  mutation CreatePerson($name: String!, $born: Int) {
    createPeople(
      input: [{ 
        name: $name, 
        born: $born 
      }]
    ) {
      people {
        name
        born
      }
    }
  }
`;
```

Lets break down the CreatePerson mutation 

This mutation creates a new person record in the database. Here's what each part does:

The variables
- ***$name: String!*** — A required text field (the ! means it can't be null)
- ***$born: Int*** — An optional integer for birth year

The mutation itself

- ***createPeople** is the mutation operation, which was auto-generated by Neo4j GraphQL based on a Person type in your schema
- ***input: [{ ... }]*** — Takes an array of objects, so you could technically create multiple people at once, but here we're just creating one

The return block
```JSON
graphqlpeople {
  name
  born
}
```

After the mutation succeeds, it returns the newly created person's name and born fields. This confirms what was actually saved and is useful for updating the UI without a separate query.

Example usage
You'd call this with something like:
```javascript
createPerson({ 
  variables: { 
    name: "Tom Hanks", 
    born: 1956 
  } 
});
```
The plural naming (createPeople, people) follows Neo4j GraphQL's convention of using array-based inputs even for single records, which gives the flexibility to create many or just one entry in the database. 


## The Form To Capture A New Movie

As we're using TypeScipt, `src/types/movie.ts` now hold two new types that are needed for new Movies and Persons. Also recall that a mutation always sends back or more fields.  This means we also a type to hold the response.  

Along with TypeScript types, a form is required for the user to input the needed values.  This will be the `src/components/MovieForm.tsx` component. 

Looking at `src/components/MovieForm.tsx` we observe


### The imports
```typescript
javascriptimport { graphqlClient } from '../lib/graphql-client';
import { CREATE_MOVIE } from '../graphql/operations';
```

graphqlClient — A pre-configured client ( graphql-request) that knows about the API endpoint and handles sending requests
CREATE_MOVIE — The GraphQL mutation  we are using 

### Setting up the mutation
```typescript
const createMovieMutation = useMutation({
  mutationFn: async (data: MovieFormData) =>
    graphqlClient.request<CreateMovieResponse>(CREATE_MOVIE, data),
  // ...
});
```

This is where the actual GraphQL call happens. graphqlClient.request() takes the mutation and variables (data), sends it to your GraphQL endpoint, and returns the typed response.

### Cache invalidation on success
```javascript
onSuccess: () => {
  queryClient.invalidateQueries({ queryKey: ['movies'] });
  onComplete();
}
```

After a successful mutation, this tells TanStack Query to refetch any queries tagged with ['movies']. This keeps your movie list in sync without manually updating state — a common pattern when mutations affect data displayed elsewhere.

### Triggering the mutation
```javascript
createMovieMutation.mutate(formData);
```

This sends the GraphQL request. The formData object becomes the variables passed to CREATE_MOVIE.

### Using mutation state for UI feedback
```javascript
disabled={createMovieMutation.isPending}
// ...

{createMovieMutation.isPending ? 'Creating...' : 'Create Movie'}
```

TanStack Query tracks the request lifecycle automatically. isPending is true while the GraphQL request is in flight, which is used here to disable the button and show loading text.



### Cache Invalidation 

When you create a movie, notice these steps:

1. The mutation runs (`createMovieMutation.mutate()`)
2. On success, we call `queryClient.invalidateQueries({ queryKey: ['movies'] })`
3. React Query automatically re-fetches the movies list
4. The UI updates with the new movie included

This pattern ensures your UI stays in sync with the database.

The rest of the component is standard React form handling — managing local state, validation, and rendering inputs. 


## Test Creating A Movie

Launch our Movie Manager with `npm run dev`

Now Try creating a new movie:

1. Click "Add Movie" in the navigation ( If you interested to see the React that does this, take a look  in `src/App.tsx` )
![](/images/chapter3_new_movie.png)

2. Enter a title (required field)
3. Add a release year (requierd field) and optionally, a tagline
4. Click "Create Movie"
5. You should be redirected to the movie list
6. Your new movie should appear in the list, likely to be at the bottom of the page



## What You've Learned

✅ Writing GraphQL mutations  
✅ Using React Query's `useMutation` hook  
✅ Building controlled form components  
✅ Cache invalidation for automatic UI updates  
✅ Handling form validation and errors  
✅ Using TypeScript for type-safe forms

## Extra

Extend the Movie Manager app with:

1. Adding validation for the release year (should be a reasonable year)
2. Creating a similar form for adding new people (actors/directors)
3. Adding a success message after creating a movie
4. Dealing with the error when a user tries to enter a movie that already exists with the same title. 

**Next**: [Chapter 4: Updating Existing Data](/chapter4/TUTORIAL_CHAPTER4.md)

---

