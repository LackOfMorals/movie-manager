# Chapter 7: Search and Filter

Search is one of the most powerful features in a graph database. In this chapter, we'll look at how flexible searching can be implemented using GraphQL's filtering capabilities.

> It is assumed that you have a local copy of this repository.  If you have not, then clone it now
> - ```git clone https://github.com/LackOfMorals/movie-manager.git```
> 
> And then move into this chapter
> - ```cd movie-manager/chapter7```

## Understanding GraphQL Filtering

Neo4j's GraphQL library provides powerful [filtering](https://neo4j.com/docs/graphql/current/filtering/) operators including:-  

- **`contains`/ `startsWith` / `endsWith`**: String comparisons (case-insensitive)
- **`lt` / `lte` / `gt` / `gte`**: Numeric comparisons
- **`some`**: Relationship filter  
- **`OR` /  `AND` /  `NOT`**: Logical operators

Example: Find the movie "The Matrix" 

```graphql
query {
  movies ( 
  where: { title: { eq: "The Matrix" } } ) 
  { 
     title
     tagline
     released 
  }
}

```
This query fetches a specific movie - "The Matrix". Here's what each part does:
- The operation `movies(where: { title: { eq: "The Matrix" } })`
- movies: The query field, auto-generated by Neo4j GraphQL from the GraphQL Schema
- where — A filter clause that narrows down which movies to return
- `{ title: { eq: "The Matrix" } }`: Only return movies where the title equals "The Matrix"

- The return fields `title tagline released` : Specifies exactly which fields we want back. 

For searching in Movie Manager, we will allow for filters on title or tagline.  The `where` part of the GraphQL query will look like this

```graphql
 where: {
      OR: [
        { title: { contains: $searchTerm } },
        { tagline: { contains: $searchTerm } }
      ]
    }
```


## Adding Search To Movie Manager
As seen in previous chapters, searching will be primarily contained within a component - `/src/components/Search.tsx`. Let's take a look at how GraphQL is being used within it.


### Query with dynamic variables
```javascript
const { data, isLoading } = useQuery({
  queryKey: ['search', activeSearch],
  queryFn: async () =>
    graphqlClient.request<SearchResponse>(SEARCH_ALL, { searchTerm: activeSearch }),
  enabled: activeSearch.length > 0
});
```

The SEARCH_ALL operation receives searchTerm as a variable. This maps to our GraphQL query that searches across movies titles and taglines. 

### Conditional query execution
`enabled: activeSearch.length > 0` prevents the GraphQL request from firing until the user actually submits a search. Without this, TanStack Query would run the query immediately with an empty string.

### Query key includes search term
`queryKey: ['search', activeSearch]` each unique search term gets its own cache entry. Searching "Matrix" then "Hanks" then "Matrix" again — that third search returns instantly from cache rather than hitting our GraphQL endpoint.

### Two-stage state pattern

```javascript
const [searchTerm, setSearchTerm] = useState('');
const [activeSearch, setActiveSearch] = useState('');

const handleSearch = (e: React.FormEvent) => {
  e.preventDefault();
  if (searchTerm.trim()) {
    setActiveSearch(searchTerm);
  }
};
```

- `searchTerm`: Tracks what the user is typing (controlled input)
- `activeSearch`: Triggers the actual GraphQL query

This separation means the query only fires on form submit, not on every keystroke. Without this, typing "Matrix" would fire six queries: "M", "Ma", "Mat", "Matr", "Matri", "Matrix".

### Response shape
```typescript
interface SearchResponse {
  movies: Movie[];
}
```

The query returns movies with their relationships (peopleActedIn, peopleDirected) already included — a single GraphQL query fetches the movie nodes and traverses to connected people nodes in one request. This is where graph databases have an advantage compared to REST, where you'd typically need multiple round trips.

## Test Search Functionality

Try different searches:

1. **Movie title**: Search for "Matrix" or "Inception"
2. **Tagline keywords**: Search for "reality" or "dream"
3. **Partial matches**: Search for "mat" to find Matrix


## What You've Learned

✅ Using GraphQL filter operators  
✅ Combining filters with OR conditions    
✅ Building a search UI with React  
✅ Highlighting search matches  
✅ Handling empty search results


## Extra

Enhance the search:

1. Add sorting options (by title, year, relevance)
2. Implement search suggestions as user types
3. Add filters for release year ranges
4. Show search history

---

## Congratulations!

You've completed the Movie Manager tutorial! You now have a fully functional web application that demonstrates the core concepts of building with Neo4j and GraphQL.

### What You've Built

✅ A React application connected to Neo4j via GraphQL  
✅ Full CRUD operations (Create, Read, Update, Delete)  
✅ Relationship management between movies and people  
✅ Search functionality with GraphQL filtering  

### Where To Go From Here

- Explore the [Neo4j GraphQL Library documentation](https://neo4j.com/docs/graphql/current/)
- Take courses at [Neo4j GraphAcademy](https://graphacademy.neo4j.com/)
- Add authentication to protect your API
- Deploy your application to production

---